<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ session.name }} - Multi-Agent AI System</title>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/9.1.6/marked.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3182ce;
            --primary-dark: #2b6cb0;
            --secondary: #edf2f7;
            --accent: #38b2ac;
            --success: #48bb78;
            --warning: #ecc94b;
            --error: #f56565;
            --text-primary: #2d3748;
            --text-secondary: #718096;
            --border: #e2e8f0;
            --glass: rgba(247, 250, 252, 0.9);
            --chat-bg: #f7fafc;
            --sidebar-bg: #edf2f7;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--chat-bg);
            min-height: 100vh;
            color: var(--text-primary);
            overflow: hidden; /* Prevent body scroll */
        }

        .chat-app {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: 60px 1fr;
            grid-template-areas:
                "header header"
                "sidebar main";
            height: 100vh;
            gap: 1px;
            background: rgba(0, 0, 0, 0.05);
        }

        /* Header */
        .header {
            grid-area: header;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            position: relative;
            overflow: hidden;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .back-btn {
            background: none;
            border: none;
            padding: 8px;
            border-radius: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .back-btn:hover {
            background: var(--secondary);
            color: var(--text-primary);
        }

        .session-info {
            display: flex;
            flex-direction: column;
        }

        .session-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 2px;
        }

        .session-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* Status indicators removed for cleaner UI */

        /* Sidebar */
        .sidebar {
            grid-area: sidebar;
            background: var(--sidebar-bg);
            backdrop-filter: blur(10px);
            padding: 24px;
            color: var(--text-primary);
            overflow-y: auto;
            height: calc(100vh - 60px); /* Fixed height minus header */
        }

        .sidebar-section {
            margin-bottom: 32px;
        }

        .sidebar-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .agent-card {
            background: white;
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .agent-card:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transform: translateY(-2px);
        }

        .agent-card.active {
            border-color: var(--primary);
            box-shadow: 0 0 12px rgba(49, 130, 206, 0.1);
        }

        .agent-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .agent-icon {
            width: 24px;
            height: 24px;
            color: var(--accent);
        }

        .agent-name {
            font-weight: 600;
            font-size: 14px;
        }

        .agent-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 20px;
        }

        .metric {
            background: white;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            border: 1px solid var(--border);
        }

        .metric-value {
            font-size: 18px;
            font-weight: 700;
            color: var(--accent);
        }

        .metric-label {
            font-size: 10px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Main Chat Area */
        .main-content {
            grid-area: main;
            background: var(--chat-bg);
            display: flex;
            flex-direction: column;
            position: relative;
            height: calc(100vh - 60px); /* Fixed height minus header */
        }

        .chat-container {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }

        .message {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            flex-direction: row-reverse;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }

        .user-avatar {
            background: var(--primary);
            color: white;
        }

        .ai-avatar {
            background: var(--accent);
            color: white;
        }

        .message-content {
            max-width: 70%;
            background: white;
            border-radius: 18px;
            padding: 16px 20px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.05);
            border: 1px solid var(--border);
            position: relative;
        }

        .message.user .message-content {
            background: var(--primary);
            color: white;
        }

        .message-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .message.user .message-meta {
            color: rgba(255, 255, 255, 0.8);
        }

        .agent-badge {
            background: var(--accent);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .agent-badge.source-rag {
            background: #667eea; /* Soft blue for RAG/Resources */
        }

        .agent-badge.source-tools {
            background: #ed8936; /* Soft orange for Tools */
        }

        .agent-badge.source-llm {
            background: var(--success); /* Soft green for General AI */
        }

        .tools-used {
            display: flex;
            gap: 6px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .tool-badge {
            background: rgba(56, 178, 172, 0.1);
            color: var(--accent);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 500;
            border: 1px solid rgba(56, 178, 172, 0.2);
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Markdown Content Styles */
        .markdown-content h1, .markdown-content h2, .markdown-content h3, 
        .markdown-content h4, .markdown-content h5, .markdown-content h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            line-height: 1.2;
        }

        .markdown-content h1 { font-size: 1.5em; }
        .markdown-content h2 { font-size: 1.3em; }
        .markdown-content h3 { font-size: 1.1em; }

        .markdown-content p {
            margin: 8px 0;
            line-height: 1.5;
        }

        .markdown-content ul, .markdown-content ol {
            margin: 8px 0;
            padding-left: 20px;
        }

        .markdown-content li {
            margin: 4px 0;
            line-height: 1.4;
        }

        .markdown-content blockquote {
            margin: 12px 0;
            padding: 12px 16px;
            border-left: 4px solid var(--primary);
            background: rgba(49, 130, 206, 0.05);
            border-radius: 0 8px 8px 0;
            font-style: italic;
        }

        .markdown-content code {
            background: rgba(0, 0, 0, 0.08);
            padding: 3px 6px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            color: #e53e3e;
        }

        .markdown-content pre {
            background: rgba(0, 0, 0, 0.05);
            padding: 16px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 16px 0;
            border: 1px solid var(--border);
        }

        .markdown-content pre code {
            background: none;
            padding: 0;
            color: inherit;
            font-size: 0.85em;
        }

        .markdown-content a {
            color: var(--primary);
            text-decoration: underline;
            font-weight: 500;
        }

        .markdown-content a:hover {
            text-decoration: none;
            background: rgba(49, 130, 206, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
        }

        .markdown-content table {
            width: 100%;
            border-collapse: collapse;
            margin: 16px 0;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        .markdown-content th, .markdown-content td {
            border: 1px solid var(--border);
            padding: 12px;
            text-align: left;
        }

        .markdown-content th {
            background: var(--secondary);
            font-weight: 600;
        }

        .markdown-content tr:nth-child(even) {
            background: rgba(0, 0, 0, 0.02);
        }

        .markdown-content strong {
            font-weight: 600;
            color: var(--text-primary);
        }

        .markdown-content em {
            font-style: italic;
            color: var(--text-secondary);
        }

        .markdown-content hr {
            margin: 20px 0;
            border: none;
            border-top: 2px solid var(--border);
            border-radius: 1px;
        }

        /* Input Area */
        .input-area {
            border-top: 1px solid var(--border);
            padding: 20px 24px;
            background: var(--glass);
            backdrop-filter: blur(10px);
        }

        .rag-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 12px;
        }

        .add-file-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(56, 178, 172, 0.2);
        }

        .add-file-btn:hover {
            background: #2c9691;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(56, 178, 172, 0.3);
        }

        .add-file-btn:active {
            transform: translateY(0);
        }

        .add-file-btn i {
            font-size: 18px;
        }

        .input-container {
            display: flex;
            gap: 12px;
            align-items: flex-end;
            position: relative;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        .message-input {
            width: 100%;
            min-height: 50px;
            max-height: 120px;
            padding: 14px 50px 14px 16px;
            border: 2px solid var(--border);
            border-radius: 25px;
            font-size: 14px;
            resize: none;
            outline: none;
            transition: all 0.3s ease;
            background: white;
            font-family: inherit;
        }

        .message-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(49, 130, 206, 0.1);
        }

        .send-button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            border: none;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .send-button:hover {
            background: var(--primary-dark);
            transform: translateY(-50%) scale(1.1);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: translateY(-50%);
        }

        /* File Upload Modal */
        #file-upload-modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0, 0, 0, 0.7) !important;
            z-index: 9999 !important;
            display: none !important;
            align-items: center !important;
            justify-content: center !important;
            padding: 20px;
        }

        #file-upload-modal.show {
            display: flex !important;
        }

        #file-upload-modal .modal {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 550px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            position: relative;
            transform: scale(0.9);
            opacity: 0;
            transition: all 0.3s ease;
        }

        #file-upload-modal.show .modal {
            transform: scale(1);
            opacity: 1;
        }

        #file-upload-modal .modal-title {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        #file-upload-modal .modal-subtitle {
            font-size: 15px;
            color: var(--text-secondary);
            margin-bottom: 30px;
        }

        #file-upload-modal .file-drop-zone {
            border: 3px dashed #cbd5e1;
            border-radius: 16px;
            padding: 60px 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8fafc;
            margin-bottom: 20px;
        }

        #file-upload-modal .file-drop-zone:hover {
            border-color: var(--primary);
            background: #eff6ff;
        }

        #file-upload-modal .file-drop-zone.dragover {
            border-color: var(--primary);
            background: #dbeafe;
            border-style: solid;
        }

        #file-upload-modal .file-drop-zone i {
            font-size: 56px;
            color: var(--primary);
            margin-bottom: 15px;
            display: block;
        }

        #file-upload-modal .file-drop-zone p {
            color: var(--text-secondary);
            font-size: 16px;
            font-weight: 500;
        }

        #file-upload-modal .files-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        #file-upload-modal .file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
            background: #f1f5f9;
            border-radius: 8px;
            margin-bottom: 8px;
            border: 2px solid #e2e8f0;
        }

        #file-upload-modal .file-item span {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #file-upload-modal .remove-file-btn {
            background: white;
            border: 2px solid #fee2e2;
            color: var(--error);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 10px;
            border-radius: 6px;
            transition: all 0.2s;
            font-weight: bold;
            margin-left: 12px;
        }

        #file-upload-modal .remove-file-btn:hover {
            background: #fee2e2;
        }

        #file-upload-modal .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 10px;
        }

        #file-upload-modal .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
        }

        #file-upload-modal .btn-primary {
            background: var(--primary);
            color: white;
        }

        #file-upload-modal .btn-primary:hover:not(:disabled) {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(49, 130, 206, 0.4);
        }

        #file-upload-modal .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #file-upload-modal .btn-secondary {
            background: #f1f5f9;
            color: var(--text-primary);
            border: 2px solid #e2e8f0;
        }

        #file-upload-modal .btn-secondary:hover {
            background: #e2e8f0;
        }

        /* Progress Bar Styles */
        .progress-section {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .progress-header span:first-child {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .progress-header span:last-child {
            font-size: 14px;
            font-weight: 700;
            color: var(--primary);
        }

        .progress-bar-container {
            width: 100%;
            height: 12px;
            background: #e2e8f0;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: 6px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-details {
            font-size: 13px;
            color: var(--text-secondary);
        }

        /* Workflow panel removed for cleaner UI */

        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 16px 20px;
            background: rgba(49, 130, 206, 0.05);
            border-radius: 18px;
            margin-bottom: 16px;
            color: var(--primary);
            font-size: 14px;
        }

        /* Streaming response styles */
        #partial-response {
            opacity: 0.8;
        }

        #partial-response .partial-content::after {
            content: '‚ñã';
            color: var(--primary);
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .streaming-cursor {
            display: inline;
            color: var(--primary);
            font-weight: bold;
            animation: blink 1s infinite;
            margin-left: 2px;
            font-size: 1.1em;
        }
        
        .partial-content {
            min-height: 20px;
            position: relative;
        }
        
        #partial-response .message-content {
            background: linear-gradient(90deg, transparent, rgba(49, 130, 206, 0.03), transparent);
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .thinking-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--primary);
            animation: thinking 1.4s infinite ease-in-out;
        }

        .thinking-dot:nth-child(2) { animation-delay: 0.2s; }
        .thinking-dot:nth-child(3) { animation-delay: 0.4s; }

        @keyframes thinking {
            0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; }
            40% { transform: scale(1.2); opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .chat-app {
                grid-template-columns: 260px 1fr;
                grid-template-areas:
                    "header header"
                    "sidebar main";
            }
        }

        @media (max-width: 768px) {
            .chat-app {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "main";
            }
            
            .sidebar {
                display: none;
            }
            
            .header {
                padding: 0 16px;
            }
            
            .chat-container,
            .input-area {
                padding: 16px;
            }

            .header-left {
                gap: 8px;
            }

            .session-info {
                font-size: 14px;
            }
        }

        /* Custom Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(113, 128, 150, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(113, 128, 150, 0.5);
        }

        /* Screen reader only content */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }
    </style>
</head>
<body>
    <div class="chat-app">
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <button class="back-btn" onclick="goBack()" title="Back to Dashboard">
                    <i data-lucide="arrow-left" style="width: 20px; height: 20px;">‚Üê</i>
                    <span style="font-size: 14px; margin-left: 4px;">Dashboard</span>
                </button>
                <div class="session-info">
                    <div class="session-name">{{ session.name }}</div>
                    <div class="session-meta">
                        {{ session.message_count }} messages ‚Ä¢ 
                        Last active {{ session.last_active.strftime('%m/%d/%Y %I:%M %p') }}
                    </div>
                </div>
            </div>
            <div class="header-right">
                <!-- Status indicators removed for cleaner UI -->
            </div>
        </header>

        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-section">
                <h3 class="sidebar-title">Session Metrics</h3>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="message-count">{{ session.message_count }}</div>
                        <div class="metric-label">Messages</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="tool-usage">{{ session.tools_used }}</div>
                        <div class="metric-label">Tools Used</div>
                    </div>
                </div>
            </div>
        </aside>

        <!-- Main Chat Area -->
        <main class="main-content">
            <div class="chat-container" id="chat-container">
                <!-- Load existing messages -->
                {% if messages %}
                    {% for msg in messages %}
                    <div class="message user">
                        <div class="message-avatar user-avatar">{{ user.username[0].upper() }}</div>
                        <div class="message-content">
                            <div class="message-meta">
                                <span>You</span>
                                <span>{{ msg.created_at.strftime('%I:%M %p') }}</span>
                            </div>
                            <p>{{ msg.user_message }}</p>
                        </div>
                    </div>
                    <div class="message">
                        <div class="message-avatar ai-avatar">AI</div>
                        <div class="message-content">
                            <div class="message-meta">
                                <span class="agent-badge">{{ msg.metadata.get('agent_type', 'chatbot') }}</span>
                                <span>{{ msg.created_at.strftime('%I:%M %p') }}</span>
                            </div>
                            <div class="markdown-content">{{ msg.ai_response }}</div>
                            {% if msg.metadata.get('tools_used') %}
                            <div class="tools-used">
                                {% for tool in msg.metadata.tools_used %}
                                <span class="tool-badge">
                                    <i data-lucide="tool">üîß</i>
                                    {{ tool.replace('_', ' ') }}
                                </span>
                                {% endfor %}
                            </div>
                            {% endif %}
                        </div>
                    </div>
                    {% endfor %}
                {% else %}
                    <!-- Welcome message if no existing messages -->
                    <div class="message">
                        <div class="message-avatar ai-avatar">AI</div>
                        <div class="message-content">
                            <div class="message-meta">
                                <span class="agent-badge">System</span>
                                <span>Just now</span>
                            </div>
                            <p>Hello! I'm ready to help you in this session: "{{ session.name }}". 
                            {% if session.description %}{{ session.description }}{% endif %}
                            What would you like to discuss?</p>
                        </div>
                    </div>
                {% endif %}
            </div>

            <div class="input-area">
                <div class="input-container">
                    <!-- RAG Mode File Upload Button (shown only in RAG sessions) -->
                    {% if session.session_type == 'rag' %}
                    <div id="rag-controls" class="rag-controls">
                        <button id="add-file-btn" class="add-file-btn" title="Add file to Knowledge Base">
                            <i data-lucide="file-plus">üìÅ+</i>
                            <span>Add file to KB</span>
                        </button>
                    </div>
                    {% endif %}

                    <div class="input-wrapper">
                        <label for="message-input" class="sr-only">Type your message</label>
                        <textarea
                            id="message-input"
                            class="message-input"
                            placeholder="Type your message here..."
                            rows="1"
                            aria-label="Message input"
                            aria-describedby="send-button"
                        ></textarea>
                        <button id="send-button" class="send-button" aria-label="Send message" title="Send message">
                            <i data-lucide="send">üì§</i>
                        </button>
                    </div>
                </div>
            </div>
        </main>

    </div>

    <!-- File Upload Modal (outside chat-app for proper positioning) -->
    <div id="file-upload-modal">
        <div class="modal">
            <h3 class="modal-title">Add File to Knowledge Base</h3>
            <p class="modal-subtitle">Upload PDF, TXT, or other document formats</p>

            <form id="file-upload-form">
                <div class="file-drop-zone" id="file-drop-zone">
                    <i data-lucide="upload">üì§</i>
                    <p id="drop-zone-text">Drag and drop files here or click to browse</p>
                    <input type="file" id="file-input" accept=".pdf,.txt,.doc,.docx" hidden multiple>
                </div>

                <div id="files-list" class="files-list" style="display: none;">
                    <!-- Selected files will be listed here -->
                </div>

                <!-- Progress Section -->
                <div id="upload-progress-container" style="display: none;">
                    <div class="progress-section">
                        <div class="progress-header">
                            <span id="progress-status-text">Preparing upload...</span>
                            <span id="progress-percentage">0%</span>
                        </div>
                        <div class="progress-bar-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                        <div class="progress-details">
                            <span id="progress-details-text">Initializing...</span>
                        </div>
                    </div>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="closeFileUploadModal()">
                        Cancel
                    </button>
                    <button type="submit" class="btn btn-primary" id="upload-btn" disabled>
                        <i data-lucide="upload">üì§</i>
                        Upload to KB
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Wait for DOM and Lucide to load before initializing
        document.addEventListener('DOMContentLoaded', function() {
            function initializeLucide() {
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                } else {
                    setTimeout(initializeLucide, 100);
                }
            }
            initializeLucide();
        });

        // Session and user info from template
        const sessionId = '{{ session._id }}';
        const userId = '{{ user._id }}';
        const userName = '{{ user.username }}';
        const wsAuthToken = '{{ ws_auth_token }}';

        // Chat management class
        class ChatManager {
            constructor() {
                console.log('ChatManager constructor called');
                this.websocket = null;
                this.isProcessing = false;
                this.isAuthenticated = false;
                this.messageCount = parseInt('{{ session.message_count }}') || 0;
                this.toolUsage = parseInt('{{ session.tools_used }}') || 0;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                
                this.initializeElements();
                this.initializeWebSocket();
            }

            initializeElements() {
                this.chatContainer = document.getElementById('chat-container');
                this.messageInput = document.getElementById('message-input');
                this.sendButton = document.getElementById('send-button');
                this.messageCountEl = document.getElementById('message-count');
                this.toolUsageEl = document.getElementById('tool-usage');

                console.log('Elements initialized:', {
                    chatContainer: !!this.chatContainer,
                    messageInput: !!this.messageInput,
                    sendButton: !!this.sendButton
                });

                this.bindEvents();
            }

            bindEvents() {
                // Send message events
                if (this.sendButton) {
                    this.sendButton.addEventListener('click', () => {
                        console.log('Send button clicked');
                        this.sendMessage();
                    });
                    console.log('Send button event listener added');
                } else {
                    console.error('Send button not found!');
                }
                this.messageInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        console.log('Enter key pressed');
                        this.sendMessage();
                    }
                });

                // Auto-resize textarea
                this.messageInput.addEventListener('input', function() {
                    this.style.height = 'auto';
                    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                });
            }

            async initializeWebSocket() {
                try {
                    // Get auth token from cookie
                    const authToken = this.getAuthTokenFromCookie();
                    console.log('Auth token retrieved:', authToken ? `${authToken.substring(0, 20)}...` : 'null');
                    
                    if (!authToken) {
                        console.error('No auth token found');
                        this.updateSystemStatus('error');
                        return;
                    }
                    
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}`;
                    console.log('Connecting to WebSocket:', wsUrl);
                    
                    this.websocket = new WebSocket(wsUrl);
                    
                    this.websocket.onopen = () => {
                        console.log('WebSocket connected, sending auth message...');
                        this.reconnectAttempts = 0;

                        // Send authentication
                        const authMessage = {
                            auth_token: authToken
                        };
                        console.log('Sending auth message:', authMessage);
                        this.websocket.send(JSON.stringify(authMessage));
                        console.log('Auth message sent, waiting for confirmation...');
                    };
                    
                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleWebSocketMessage(data);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                        }
                    };
                    
                    this.websocket.onclose = (event) => {
                        console.log('WebSocket disconnected:', event.code);
                        this.isAuthenticated = false;

                        // Attempt to reconnect
                        this.scheduleReconnect();
                    };

                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        this.isAuthenticated = false;
                    };
                    
                } catch (error) {
                    console.error('Failed to initialize WebSocket:', error);
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts >= this.maxReconnectAttempts) {
                    console.log('Max reconnection attempts reached');
                    return;
                }

                this.reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);

                console.log(`Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);

                setTimeout(() => {
                    this.initializeWebSocket();
                }, delay);
            }

            getAuthTokenFromCookie() {
                // Return the WebSocket auth token passed from the template
                return wsAuthToken;
            }

            handleWebSocketMessage(data) {
                switch (data.type) {
                    case 'auth_success':
                        console.log('Authentication successful');
                        break;
                    
                    case 'error':
                        console.error('WebSocket error:', data.message);
                        this.isAuthenticated = false;
                        break;

                    case 'thinking':
                        const thinkingMsg = data.message || 'Processing...';
                        this.showThinkingIndicator(thinkingMsg);
                        break;
                    
                    case 'partial_response':
                        this.hideThinkingIndicator();
                        this.updatePartialResponse(data.message, data.agent_type, data.tools_used);
                        break;
                    
                    case 'response':
                    case 'chat_response':
                        console.log('Received chat response data:', data);
                        console.log('Agent type in response:', data.agent_type);
                        console.log('Selected agent in response:', data.selected_agent);
                        console.log('Metadata in response:', data.metadata);
                        console.log('Tools used in response:', data.tools_used);
                        this.hideThinkingIndicator();
                        
                        // Remove partial response if it exists and replace with final
                        const partialDiv = document.getElementById('partial-response');
                        if (partialDiv) {
                            partialDiv.remove();
                        }
                        
                        this.addAIMessage(data.response || data.message, data.agent_type, data.tools_used, data.metadata);
                        this.isProcessing = false;
                        this.enableInput();
                        break;
                    
                    case 'error':
                        this.hideThinkingIndicator();
                        this.showError(data.message);
                        this.isProcessing = false;
                        this.enableInput();
                        break;
                    
                    case 'connection_established':
                        console.log('WebSocket connection established:', data.message);
                        console.log('Authentication successful - ready to send messages');
                        this.isAuthenticated = true;
                        break;
                    
                    default:
                        console.log('Unknown message type:', data.type);
                }
            }

            sendMessage() {
                if (this.isProcessing || !this.websocket || this.websocket.readyState !== WebSocket.OPEN || !this.isAuthenticated) {
                    console.log('Cannot send message:', {
                        isProcessing: this.isProcessing,
                        websocketReady: this.websocket && this.websocket.readyState === WebSocket.OPEN,
                        isAuthenticated: this.isAuthenticated
                    });
                    return;
                }

                const message = this.messageInput.value.trim();
                if (!message) return;

                // Add user message to chat
                this.addUserMessage(message);
                
                // Clear input
                this.messageInput.value = '';
                this.messageInput.style.height = 'auto';
                
                // Disable input while processing
                this.disableInput();
                this.isProcessing = true;

                // Get session type from data attribute or default to 'ai'
                const sessionType = '{{ session.session_type or "ai" }}';

                // Show session-type-specific thinking indicator
                const thinkingMessage = sessionType === 'rag' ? 'Searching in your docs...' : 'Thinking...';
                this.showThinkingIndicator(thinkingMessage);

                // Send to WebSocket
                this.websocket.send(JSON.stringify({
                    type: 'chat_message',
                    message: message,
                    session_type: sessionType,
                    session_id: sessionId,
                    user_id: userId
                }));

                // Update metrics
                this.messageCount++;
                this.updateMetrics();
            }

            addUserMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message user';
                
                const now = new Date();
                const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                messageDiv.innerHTML = `
                    <div class="message-avatar user-avatar">${userName.charAt(0).toUpperCase()}</div>
                    <div class="message-content">
                        <div class="message-meta">
                            <span>You</span>
                            <span>${timeString}</span>
                        </div>
                        <p>${this.escapeHtml(message)}</p>
                    </div>
                `;
                
                this.chatContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            addAIMessage(message, agentType = 'chatbot', toolsUsed = [], metadata = {}) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message';
                
                const now = new Date();
                const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                // Determine source type and icon
                const sourceInfo = this.getSourceInfo(agentType, toolsUsed);
                
                let toolsHtml = '';
                if (toolsUsed && toolsUsed.length > 0) {
                    toolsHtml = `
                        <div class="tools-used">
                            ${toolsUsed.map(tool => `
                                <span class="tool-badge">
                                    <i data-lucide="tool">üîß</i>
                                    ${this.escapeHtml(tool.replace('_', ' '))}
                                </span>
                            `).join('')}
                        </div>
                    `;
                }
                
                messageDiv.innerHTML = `
                    <div class="message-avatar ai-avatar">AI</div>
                    <div class="message-content">
                        <div class="message-meta">
                            <span class="agent-badge ${sourceInfo.class}">
                                <i data-lucide="${sourceInfo.icon}"></i>
                                ${sourceInfo.label}
                            </span>
                            <span>${timeString}</span>
                        </div>
                        <div class="markdown-content">${this.formatMessage(message)}</div>
                        ${toolsHtml}
                    </div>
                `;
                
                this.chatContainer.appendChild(messageDiv);
                this.scrollToBottom();

                // Re-initialize Lucide icons for the new content
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }

            addSystemMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = 'message system-message';
                messageDiv.style.cssText = `
                    background: rgba(56, 178, 172, 0.1);
                    border-left: 3px solid var(--accent);
                    padding: 12px 16px;
                    margin: 16px 0;
                    border-radius: 8px;
                    font-size: 14px;
                    color: var(--text-primary);
                `;
                messageDiv.textContent = message;
                this.chatContainer.appendChild(messageDiv);
                this.scrollToBottom();
            }

            getSourceInfo(agentType, toolsUsed) {
                console.log('getSourceInfo called with:', {
                    agentType: agentType,
                    agentTypeType: typeof agentType,
                    toolsUsed: toolsUsed,
                    toolsUsedLength: toolsUsed ? toolsUsed.length : 'null'
                });
                
                // Determine source type based on agent and tools used
                if (agentType === 'rag_agent' || agentType === 'rag') {
                    console.log('Returning RAG source info');
                    return {
                        icon: 'database',
                        label: 'Knowledge Base',
                        class: 'source-rag'
                    };
                } else if (toolsUsed && toolsUsed.length > 0 && (agentType === 'chatbot' || agentType === 'chat')) {
                    console.log('Returning Tools source info');
                    return {
                        icon: 'tool',
                        label: 'Tools',
                        class: 'source-tools'
                    };
                } else if (agentType === 'chatbot' || agentType === 'chat') {
                    console.log('Returning AI source info');
                    return {
                        icon: 'brain',
                        label: 'AI Assistant',
                        class: 'source-llm'
                    };
                } else {
                    // Fallback - show the actual agent type for debugging
                    console.log('Returning fallback source info for:', agentType);
                    return {
                        icon: 'help-circle',
                        label: agentType || 'Unknown',
                        class: 'source-llm'
                    };
                }
            }

            showThinkingIndicator(message = 'AI is thinking...') {
                // Remove any existing thinking indicator
                this.hideThinkingIndicator();
                
                const thinkingDiv = document.createElement('div');
                thinkingDiv.className = 'thinking-indicator';
                thinkingDiv.id = 'thinking-indicator';
                
                thinkingDiv.innerHTML = `
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                    <span>${message}</span>
                `;
                
                this.chatContainer.appendChild(thinkingDiv);
                this.scrollToBottom();
            }

            hideThinkingIndicator() {
                const thinkingIndicator = document.getElementById('thinking-indicator');
                if (thinkingIndicator) {
                    thinkingIndicator.remove();
                }
            }

            updatePartialResponse(message, agentType = 'chatbot', toolsUsed = []) {
                let partialDiv = document.getElementById('partial-response');
                
                if (!partialDiv) {
                    partialDiv = document.createElement('div');
                    partialDiv.className = 'message';
                    partialDiv.id = 'partial-response';
                    
                    const now = new Date();
                    const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                    
                    // Get proper source info based on agent type
                    const sourceInfo = this.getSourceInfo(agentType, toolsUsed);
                    
                    partialDiv.innerHTML = `
                        <div class="message-avatar ai-avatar">AI</div>
                        <div class="message-content">
                            <div class="message-meta">
                                <span class="agent-badge ${sourceInfo.class}">
                                    <i data-lucide="${sourceInfo.icon}"></i>
                                    ${sourceInfo.label}
                                </span>
                                <span>${timeString}</span>
                            </div>
                            <div class="markdown-content partial-content" data-raw-message=""></div>
                        </div>
                    `;
                    
                    this.chatContainer.appendChild(partialDiv);
                    
                    // Initialize Lucide icons
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                } 
                
                // Optimized content update - only if message actually changed
                const contentEl = partialDiv.querySelector('.partial-content');
                if (contentEl && contentEl.dataset.rawMessage !== message) {
                    contentEl.dataset.rawMessage = message;
                    
                    // Use requestAnimationFrame to batch DOM updates
                    if (!this.streamingUpdatePending) {
                        this.streamingUpdatePending = true;
                        requestAnimationFrame(() => {
                            // Format the message first, then add cursor
                            const formattedMessage = this.formatMessage(message);
                            // Add cursor at the end, outside of any markdown formatting
                            contentEl.innerHTML = formattedMessage + '<span class="streaming-cursor">|</span>';
                            this.streamingUpdatePending = false;
                            this.scrollToBottom();
                        });
                    }
                }
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.className = 'message';
                
                const now = new Date();
                const timeString = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                
                errorDiv.innerHTML = `
                    <div class="message-avatar ai-avatar">AI</div>
                    <div class="message-content" style="border-color: var(--error); background: rgba(239, 68, 68, 0.05);">
                        <div class="message-meta">
                            <span class="agent-badge" style="background: var(--error);">Error</span>
                            <span>${timeString}</span>
                        </div>
                        <p>Sorry, I encountered an error: ${this.escapeHtml(message)}</p>
                    </div>
                `;
                
                this.chatContainer.appendChild(errorDiv);
                this.scrollToBottom();
            }

            /* Workflow status and connection status functions removed for cleaner UI */

            updateMetrics() {
                if (this.messageCountEl) {
                    this.messageCountEl.textContent = this.messageCount;
                }
                if (this.toolUsageEl) {
                    this.toolUsageEl.textContent = this.toolUsage;
                }
            }

            disableInput() {
                this.messageInput.disabled = true;
                this.sendButton.disabled = true;
                this.sendButton.style.opacity = '0.5';
            }

            enableInput() {
                this.messageInput.disabled = false;
                this.sendButton.disabled = false;
                this.sendButton.style.opacity = '1';
                this.messageInput.focus();
            }

            scrollToBottom() {
                setTimeout(() => {
                    this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
                }, 100);
            }

            formatMessage(message) {
                // Use Marked.js for markdown parsing with security settings
                if (typeof marked !== 'undefined') {
                    // Configure marked for security
                    marked.setOptions({
                        sanitize: false,
                        gfm: true,
                        breaks: true,
                        highlight: null
                    });
                    
                    try {
                        return marked.parse(message);
                    } catch (e) {
                        console.error('Markdown parsing error:', e);
                        // Fallback to basic formatting
                        return this.basicFormatMessage(message);
                    }
                } else {
                    // Fallback if marked is not loaded
                    return this.basicFormatMessage(message);
                }
            }
            
            basicFormatMessage(message) {
                // First escape HTML to prevent XSS
                message = this.escapeHtml(message);
                
                // Convert URLs to links (now safe since HTML is escaped)
                const urlRegex = /(https?:\/\/[^\s]+)/g;
                message = message.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener">$1</a>');
                
                // Convert newlines to <br>
                message = message.replace(/\n/g, '<br>');
                
                return message;
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }
        }

        // Initialize chat manager when DOM is loaded
        let chatManager;
        
        // Test WebSocket authentication directly
        function testWebSocketAuth() {
            console.log('Testing WebSocket auth directly...');
            const sessionId = '{{ session._id }}';
            const wsAuthToken = '{{ ws_auth_token }}';
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/${sessionId}`;
            
            console.log('Creating direct WebSocket connection to:', wsUrl);
            const testWs = new WebSocket(wsUrl);
            
            testWs.onopen = function() {
                console.log('Direct WebSocket opened, sending auth...');
                const authMessage = { auth_token: wsAuthToken };
                console.log('Sending auth message:', authMessage);
                testWs.send(JSON.stringify(authMessage));
            };
            
            testWs.onmessage = function(event) {
                console.log('Direct WebSocket received:', event.data);
                const data = JSON.parse(event.data);
                if (data.type === 'connection_established') {
                    console.log('Direct auth successful!');
                    testWs.close();
                }
            };
            
            testWs.onerror = function(error) {
                console.error('Direct WebSocket error:', error);
            };
        }

        // Test function for debugging
        function testSendButton() {
            console.log('Testing send button...');
            const btn = document.getElementById('send-button');
            const input = document.getElementById('message-input');
            console.log('Button found:', !!btn);
            console.log('Input found:', !!input);
            if (input) {
                console.log('Input value:', input.value);
            }
            if (chatManager) {
                console.log('ChatManager state:', {
                    isProcessing: chatManager.isProcessing,
                    isAuthenticated: chatManager.isAuthenticated,
                    websocketReady: chatManager.websocket && chatManager.websocket.readyState === WebSocket.OPEN
                });
                chatManager.sendMessage();
            } else {
                console.log('ChatManager not initialized');
            }
        }
        
        // Basic test first
        console.log('JavaScript is loading...');
        console.log('Session ID:', '{{ session._id }}');
        console.log('WS Auth Token available:', '{{ ws_auth_token }}'.length > 0);
        
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, initializing ChatManager...');
            
            // Test if send button exists before ChatManager
            const testSendButton = document.getElementById('send-button');
            console.log('Send button exists before ChatManager:', !!testSendButton);
            
            // Process existing markdown content
            try {
                processExistingMessages();
                console.log('Markdown processing completed');
            } catch (e) {
                console.error('Markdown processing failed:', e);
            }
            
            try {
                chatManager = new ChatManager();
                console.log('ChatManager initialized successfully');
            } catch (error) {
                console.error('Failed to initialize ChatManager:', error);
                console.error('Error details:', error.stack);
            }
            
            // Fallback button test
            const fallbackButton = document.getElementById('send-button');
            if (fallbackButton) {
                fallbackButton.addEventListener('click', function() {
                    console.log('FALLBACK: Send button clicked directly!');
                });
                console.log('Fallback button listener added');
            }

            // File upload button (RAG sessions only)
            const addFileBtn = document.getElementById('add-file-btn');
            if (addFileBtn) {
                addFileBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const modal = document.getElementById('file-upload-modal');
                    if (modal) {
                        modal.classList.add('show');
                        document.body.style.overflow = 'hidden';
                        console.log('Modal opened');
                    }
                });
                console.log('File upload button listener added');
            }

            // Close modal when clicking outside
            const fileUploadModal = document.getElementById('file-upload-modal');
            if (fileUploadModal) {
                fileUploadModal.addEventListener('click', function(e) {
                    if (e.target === fileUploadModal) {
                        closeFileUploadModal();
                    }
                });
            }

            // File upload handling
            const fileDropZone = document.getElementById('file-drop-zone');
            const fileInput = document.getElementById('file-input');
            const fileUploadForm = document.getElementById('file-upload-form');

            if (fileDropZone && fileInput) {
                // Click to browse
                fileDropZone.addEventListener('click', () => {
                    fileInput.click();
                });

                // File selection (supports multiple files)
                fileInput.addEventListener('change', (e) => {
                    const files = e.target.files;
                    if (files && files.length > 0) {
                        handleFileSelect(files);
                    }
                });

                // Drag and drop (supports multiple files)
                fileDropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    fileDropZone.classList.add('dragover');
                });

                fileDropZone.addEventListener('dragleave', () => {
                    fileDropZone.classList.remove('dragover');
                });

                fileDropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    fileDropZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files && files.length > 0) {
                        handleFileSelect(files);
                    }
                });
            }

            // Form submission
            if (fileUploadForm) {
                fileUploadForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    await uploadFile();
                });
            }
        });

        // File upload helper functions
        let selectedFiles = [];

        function handleFileSelect(files) {
            console.log('handleFileSelect called with files:', files);

            // Convert FileList to Array and add to selectedFiles
            const filesArray = Array.from(files);
            selectedFiles = [...selectedFiles, ...filesArray];

            console.log('Total selected files:', selectedFiles.length);
            updateFilesDisplay();
        }

        function updateFilesDisplay() {
            const filesList = document.getElementById('files-list');
            const uploadBtn = document.getElementById('upload-btn');

            if (selectedFiles.length === 0) {
                filesList.style.display = 'none';
                if (uploadBtn) uploadBtn.disabled = true;
                return;
            }

            // Show files list
            filesList.style.display = 'block';
            filesList.innerHTML = '';

            // Add each file to the list
            selectedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <span>${file.name}</span>
                    <button type="button" class="remove-file-btn" onclick="removeFileByIndex(${index})">‚úï</button>
                `;
                filesList.appendChild(fileItem);
            });

            // Enable upload button
            if (uploadBtn) {
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = `
                    <i data-lucide="upload">üì§</i>
                    Upload ${selectedFiles.length} file${selectedFiles.length > 1 ? 's' : ''} to KB
                `;
            }

            console.log('Files display updated');
        }

        function removeFileByIndex(index) {
            selectedFiles.splice(index, 1);
            updateFilesDisplay();
        }

        function clearAllFiles() {
            selectedFiles = [];
            const fileInput = document.getElementById('file-input');
            const filesList = document.getElementById('files-list');
            const uploadBtn = document.getElementById('upload-btn');
            const progressContainer = document.getElementById('upload-progress-container');

            if (filesList) filesList.style.display = 'none';
            if (fileInput) fileInput.value = '';
            if (uploadBtn) {
                uploadBtn.disabled = true;
                uploadBtn.innerHTML = `<i data-lucide="upload">üì§</i> Upload to KB`;
            }
            if (progressContainer) progressContainer.style.display = 'none';
        }

        function closeFileUploadModal() {
            const modal = document.getElementById('file-upload-modal');
            if (modal) {
                modal.classList.remove('show');
                document.body.style.overflow = '';
            }
            clearAllFiles();
        }

        // Progress bar helper functions
        function showProgressBar() {
            const progressContainer = document.getElementById('upload-progress-container');
            const filesList = document.getElementById('files-list');

            if (progressContainer) progressContainer.style.display = 'block';
            if (filesList) filesList.style.display = 'none';
        }

        function updateProgress(statusText, percentage, detailsText) {
            const statusTextEl = document.getElementById('progress-status-text');
            const percentageEl = document.getElementById('progress-percentage');
            const progressBar = document.getElementById('progress-bar');
            const detailsTextEl = document.getElementById('progress-details-text');

            if (statusTextEl) statusTextEl.textContent = statusText;
            if (percentageEl) percentageEl.textContent = `${percentage}%`;
            if (progressBar) progressBar.style.width = `${percentage}%`;
            if (detailsTextEl) detailsTextEl.textContent = detailsText;
        }

        function hideProgressBar() {
            const progressContainer = document.getElementById('upload-progress-container');
            if (progressContainer) progressContainer.style.display = 'none';
        }

        // Flag to prevent multiple simultaneous uploads
        let isUploading = false;

        async function uploadFile() {
            console.log('uploadFile called, selectedFiles:', selectedFiles);

            // Prevent multiple simultaneous uploads
            if (isUploading) {
                console.log('Upload already in progress, ignoring duplicate call');
                return;
            }

            if (!selectedFiles || selectedFiles.length === 0) {
                alert('Please select at least one file');
                return;
            }

            isUploading = true;

            // Check if all files are PDFs
            const nonPdfFiles = selectedFiles.filter(file => !file.name.toLowerCase().endsWith('.pdf'));
            if (nonPdfFiles.length > 0) {
                alert('Only PDF files are supported at this time.');
                return;
            }

            const uploadBtn = document.getElementById('upload-btn');
            const originalText = uploadBtn.innerHTML;

            try {
                uploadBtn.disabled = true;

                // Show progress bar
                showProgressBar();
                updateProgress('Uploading files...', 5, `Uploading ${selectedFiles.length} file(s) to server`);

                const formData = new FormData();
                // Add all files to FormData
                selectedFiles.forEach(file => {
                    formData.append('files', file);
                });
                // Add session_id to determine collection
                formData.append('session_id', sessionId);

                console.log(`Uploading ${selectedFiles.length} file(s)`);
                console.log('Session ID:', sessionId);

                const response = await fetch('/api/kb/upload', {
                    method: 'POST',
                    body: formData
                });

                console.log('Upload response status:', response.status);

                if (response.ok) {
                    const result = await response.json();
                    console.log('Upload result:', result);

                    const fileCount = selectedFiles.length;

                    // Update progress - upload complete
                    updateProgress('Files uploaded', 10, 'Starting document processing...');

                    // Poll for status with progress updates
                    if (result.task_id) {
                        await pollUploadStatus(result.task_id, fileCount);
                    } else {
                        // No task_id, close immediately
                        closeFileUploadModal();
                        if (chatManager) {
                            chatManager.addSystemMessage(
                                `‚úÖ ${fileCount} file${fileCount > 1 ? 's' : ''} processed successfully!`
                            );
                        }
                        isUploading = false;  // Reset flag
                    }
                } else {
                    let errorMsg = 'Unknown error';
                    try {
                        const error = await response.json();
                        console.error('Upload error response:', error);
                        errorMsg = error.detail || JSON.stringify(error);
                    } catch (e) {
                        const textError = await response.text();
                        console.error('Upload error (text):', textError);
                        errorMsg = textError || `HTTP ${response.status}`;
                    }

                    // Show error in progress bar
                    updateProgress('Upload failed', 0, errorMsg);

                    // Wait before closing
                    setTimeout(() => {
                        hideProgressBar();
                        closeFileUploadModal();
                        if (chatManager) {
                            chatManager.addSystemMessage(
                                `‚ùå Upload error: ${errorMsg}`
                            );
                        }
                        isUploading = false;  // Reset flag
                    }, 2000);
                }
            } catch (error) {
                console.error('Upload exception:', error);

                // Show error in progress bar
                updateProgress('Upload failed', 0, error.message);

                // Wait before closing
                setTimeout(() => {
                    hideProgressBar();
                    closeFileUploadModal();
                    if (chatManager) {
                        chatManager.addSystemMessage(
                            `‚ùå Upload failed: ${error.message}`
                        );
                    }
                    isUploading = false;  // Reset flag
                }, 2000);
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.innerHTML = originalText;
                // Note: isUploading flag is reset in pollUploadStatus when complete
            }
        }

        async function pollUploadStatus(taskId, fileCount = 1) {
            const checkStatus = async () => {
                try {
                    const response = await fetch(`/api/kb/status/${taskId}`);
                    if (response.ok) {
                        const status = await response.json();
                        console.log('Upload status:', status);

                        if (status.status === 'completed') {
                            // Show completion
                            updateProgress('Processing complete!', 100, status.message || `Successfully processed ${status.files_processed} file(s)`);

                            // Wait a moment to show 100% completion
                            setTimeout(() => {
                                hideProgressBar();
                                closeFileUploadModal();

                                // Show success message in chat (use backend message which includes duplicate info)
                                if (chatManager) {
                                    chatManager.addSystemMessage(
                                        `‚úÖ ${status.message || 'Knowledge base updated!'}`
                                    );
                                }

                                // Reset upload flag
                                isUploading = false;
                            }, 1500);

                        } else if (status.status === 'error') {
                            // Show error
                            updateProgress('Error occurred', 0, status.message || 'An error occurred during processing');

                            setTimeout(() => {
                                hideProgressBar();

                                // Show error message in chat
                                if (chatManager) {
                                    chatManager.addSystemMessage(
                                        `‚ùå Error: ${status.message}`
                                    );
                                }

                                // Reset upload flag
                                isUploading = false;
                            }, 2000);

                        } else if (status.status === 'processing') {
                            // Update progress based on backend values
                            const progress = status.progress || 30; // Default to 30% if not provided
                            const filesProcessed = status.files_processed || 0;
                            const totalFiles = status.total_files || fileCount;

                            // Determine stage based on progress
                            let statusText = 'Processing documents...';
                            let detailsText = `Processing file ${filesProcessed} of ${totalFiles}`;

                            if (progress < 30) {
                                statusText = 'Extracting text...';
                                detailsText = `Extracting content from file ${filesProcessed + 1}`;
                            } else if (progress < 70) {
                                statusText = 'Generating embeddings...';
                                detailsText = `Creating vector embeddings (${filesProcessed}/${totalFiles})`;
                            } else {
                                statusText = 'Finalizing...';
                                detailsText = `Almost done (${filesProcessed}/${totalFiles})`;
                            }

                            // Use the custom message if provided
                            if (status.message) {
                                detailsText = status.message;
                            }

                            updateProgress(statusText, progress, detailsText);

                            // Continue polling
                            setTimeout(checkStatus, 2000);
                        }
                    }
                } catch (error) {
                    console.error('Status check error:', error);
                    updateProgress('Error checking status', 0, 'Failed to check upload status');
                    setTimeout(() => {
                        hideProgressBar();
                        isUploading = false;  // Reset flag
                    }, 2000);
                }
            };

            checkStatus();
        }

        // Function to process existing messages for markdown
        function processExistingMessages() {
            const markdownElements = document.querySelectorAll('.markdown-content');
            markdownElements.forEach(element => {
                const rawText = element.textContent;
                if (rawText && typeof marked !== 'undefined') {
                    try {
                        marked.setOptions({
                            sanitize: false,
                            gfm: true,
                            breaks: true,
                            highlight: null
                        });
                        element.innerHTML = marked.parse(rawText);
                    } catch (e) {
                        console.error('Error processing markdown for existing message:', e);
                    }
                }
            });
        }

        // Utility functions
        function goBack() {
            window.location.href = '/dashboard';
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl/Cmd + Enter to send message
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                if (chatManager) {
                    chatManager.sendMessage();
                }
            }
            
            // Escape to clear input
            if (e.key === 'Escape') {
                const messageInput = document.getElementById('message-input');
                if (messageInput && messageInput === document.activeElement) {
                    messageInput.value = '';
                    messageInput.style.height = 'auto';
                    messageInput.blur();
                }
            }
        });

        // Handle window beforeunload
        window.addEventListener('beforeunload', function() {
            if (chatManager && chatManager.websocket) {
                chatManager.websocket.close();
            }
        });

        // Handle visibility change to manage connection
        document.addEventListener('visibilitychange', function() {
            if (chatManager) {
                if (document.hidden) {
                    // Page is now hidden - could pause reconnection attempts
                    console.log('Page hidden');
                } else {
                    // Page is now visible - could resume connection
                    console.log('Page visible');
                    if (!chatManager.websocket || chatManager.websocket.readyState === WebSocket.CLOSED) {
                        chatManager.initializeWebSocket();
                    }
                }
            }
        });
    </script>
</body>
</html>